## 0-1 背包
0-1背包问题可以通过构建一个二维数组（也常称为“DP表”）来解决，其中行代表考虑的物品编号范围（从0到n，其中0表示还没有考虑任何物品的初始状态），列代表背包当前的容量（从0到W，其中W是背包的最大容量）。这样的数组设计正是基于动态规划的思路，有效地利用了之前计算的结果避免重复计算。

### 数组构建与理解

- **数组定义**：`dp[i][w]` 表示在只考虑前 `i` 件物品，并且背包当前容量为 `w` 时，能够装入背包的物品所能带来的最大价值。

- **数组初始化**：
    - 第一行 `dp[0][...]` 全部设为0，表示没有物品可选时，任何容量的背包价值都为0。
    - 第一列 `dp[...][0]` 也全部设为0，意味着背包容量为0时，不论有多少物品可选，都无法放入任何物品，价值自然为0。

- **状态转移**：
    - 对于数组中的每个位置 `dp[i][w]`（其中 `i >= 1` 且 `w >= 1`），有两种决策：
        1. **不放入第 `i` 件物品**(放不下)：此时 `dp[i][w]` 应继承前 `i-1` 件物品在容量为 `w` 时的最大价值，即 `dp[i-1][w]`。
        2. **放入第 `i` 件物品**(放得下)：如果当前物品的重量 `wt[i-1]` 小于等于背包当前的容量 `w`，则可以考虑放入该物品。此时背包剩余容量变为 `w-wt[i-1]`，总价值增加 `val[i-1]`，因此 `dp[i][w]` 的可能值为 `dp[i-1][w-wt[i-1]] + val[i-1]`。这里需要比较两种决策中**哪一种能带来更大的价值**。

- **最终结果**：填完整个数组后，`dp[n][W]` 即为在考虑所有 `n` 件物品且背包容量为 `W` 时，可以获得的最大价值。


## 完全背包
### 二维dp对比
0-1 背包
```java
//第二个物品开始,i代表物品，j代表背包的重量，物品用 it表示
dp[i][j] = Integer.max(dp[i-1][j],it.value+dp[i-1][j-it.weight]);

```
 完全背包
```java
dp[i][j] = Integer.max(dp[i-1][j],it.value+dp[i][j-it.weight]);
```